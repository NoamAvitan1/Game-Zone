import {
  dist_exports,
  init_dist,
  init_router,
  router_exports
} from "./chunk-N7O3HC2Y.js";
import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-AC2VUBZ6.js";

// node_modules/react-router-dom/dist/umd/react-router-dom.development.js
var require_react_router_dom_development = __commonJS({
  "node_modules/react-router-dom/dist/umd/react-router-dom.development.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_react(), (init_dist(), __toCommonJS(dist_exports)), (init_router(), __toCommonJS(router_exports))) : typeof define === "function" && define.amd ? define(["exports", "react", "react-router", "@remix-run/router"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.ReactRouterDOM = {}, global.React, global.ReactRouter, global.RemixRouter));
    })(exports, function(exports2, React, reactRouter, router) {
      "use strict";
      function _interopNamespace(e) {
        if (e && e.__esModule)
          return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n["default"] = e;
        return Object.freeze(n);
      }
      var React__namespace = _interopNamespace(React);
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      const defaultMethod = "get";
      const defaultEncType = "application/x-www-form-urlencoded";
      function isHtmlElement(object) {
        return object != null && typeof object.tagName === "string";
      }
      function isButtonElement(object) {
        return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
      }
      function isFormElement(object) {
        return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
      }
      function isInputElement(object) {
        return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
      }
      function isModifiedEvent(event) {
        return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
      }
      function shouldProcessLinkClick(event, target) {
        return event.button === 0 && // Ignore everything but left clicks
        (!target || target === "_self") && // Let browser handle "target=_blank" etc.
        !isModifiedEvent(event);
      }
      function createSearchParams(init) {
        if (init === void 0) {
          init = "";
        }
        return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
          let value = init[key];
          return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
        }, []));
      }
      function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
        let searchParams = createSearchParams(locationSearch);
        if (defaultSearchParams) {
          for (let key of defaultSearchParams.keys()) {
            if (!searchParams.has(key)) {
              defaultSearchParams.getAll(key).forEach((value) => {
                searchParams.append(key, value);
              });
            }
          }
        }
        return searchParams;
      }
      function getFormSubmissionInfo(target, options, basename) {
        let method;
        let action = null;
        let encType;
        let formData;
        if (isFormElement(target)) {
          let submissionTrigger = options.submissionTrigger;
          if (options.action) {
            action = options.action;
          } else {
            let attr = target.getAttribute("action");
            action = attr ? router.stripBasename(attr, basename) : null;
          }
          method = options.method || target.getAttribute("method") || defaultMethod;
          encType = options.encType || target.getAttribute("enctype") || defaultEncType;
          formData = new FormData(target);
          if (submissionTrigger && submissionTrigger.name) {
            formData.append(submissionTrigger.name, submissionTrigger.value);
          }
        } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
          let form = target.form;
          if (form == null) {
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
          }
          if (options.action) {
            action = options.action;
          } else {
            let attr = target.getAttribute("formaction") || form.getAttribute("action");
            action = attr ? router.stripBasename(attr, basename) : null;
          }
          method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
          encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
          formData = new FormData(form);
          if (target.name) {
            formData.append(target.name, target.value);
          }
        } else if (isHtmlElement(target)) {
          throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        } else {
          method = options.method || defaultMethod;
          action = options.action || null;
          encType = options.encType || defaultEncType;
          if (target instanceof FormData) {
            formData = target;
          } else {
            formData = new FormData();
            if (target instanceof URLSearchParams) {
              for (let [name, value] of target) {
                formData.append(name, value);
              }
            } else if (target != null) {
              for (let name of Object.keys(target)) {
                formData.append(name, target[name]);
              }
            }
          }
        }
        return {
          action,
          method: method.toLowerCase(),
          encType,
          formData
        };
      }
      const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], _excluded3 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
      function createBrowserRouter(routes, opts) {
        return router.createRouter({
          basename: opts == null ? void 0 : opts.basename,
          future: _extends({}, opts == null ? void 0 : opts.future, {
            v7_prependBasename: true
          }),
          history: router.createBrowserHistory({
            window: opts == null ? void 0 : opts.window
          }),
          hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
          routes,
          mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties
        }).initialize();
      }
      function createHashRouter(routes, opts) {
        return router.createRouter({
          basename: opts == null ? void 0 : opts.basename,
          future: _extends({}, opts == null ? void 0 : opts.future, {
            v7_prependBasename: true
          }),
          history: router.createHashHistory({
            window: opts == null ? void 0 : opts.window
          }),
          hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
          routes,
          mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties
        }).initialize();
      }
      function parseHydrationData() {
        var _window;
        let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
        if (state && state.errors) {
          state = _extends({}, state, {
            errors: deserializeErrors(state.errors)
          });
        }
        return state;
      }
      function deserializeErrors(errors) {
        if (!errors)
          return null;
        let entries = Object.entries(errors);
        let serialized = {};
        for (let [key, val] of entries) {
          if (val && val.__type === "RouteErrorResponse") {
            serialized[key] = new router.ErrorResponse(val.status, val.statusText, val.data, val.internal === true);
          } else if (val && val.__type === "Error") {
            let error = new Error(val.message);
            error.stack = "";
            serialized[key] = error;
          } else {
            serialized[key] = val;
          }
        }
        return serialized;
      }
      function BrowserRouter(_ref) {
        let {
          basename,
          children,
          window: window2
        } = _ref;
        let historyRef = React__namespace.useRef();
        if (historyRef.current == null) {
          historyRef.current = router.createBrowserHistory({
            window: window2,
            v5Compat: true
          });
        }
        let history = historyRef.current;
        let [state, setStateImpl] = React__namespace.useState({
          action: history.action,
          location: history.location
        });
        let setState = React__namespace.useCallback((newState) => {
          "startTransition" in React__namespace ? React__namespace.startTransition(() => setStateImpl(newState)) : setStateImpl(newState);
        }, [setStateImpl]);
        React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
        return React__namespace.createElement(reactRouter.Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        });
      }
      function HashRouter(_ref2) {
        let {
          basename,
          children,
          window: window2
        } = _ref2;
        let historyRef = React__namespace.useRef();
        if (historyRef.current == null) {
          historyRef.current = router.createHashHistory({
            window: window2,
            v5Compat: true
          });
        }
        let history = historyRef.current;
        let [state, setStateImpl] = React__namespace.useState({
          action: history.action,
          location: history.location
        });
        let setState = React__namespace.useCallback((newState) => {
          "startTransition" in React__namespace ? React__namespace.startTransition(() => setStateImpl(newState)) : setStateImpl(newState);
        }, [setStateImpl]);
        React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
        return React__namespace.createElement(reactRouter.Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        });
      }
      function HistoryRouter(_ref3) {
        let {
          basename,
          children,
          history
        } = _ref3;
        let [state, setStateImpl] = React__namespace.useState({
          action: history.action,
          location: history.location
        });
        let setState = React__namespace.useCallback((newState) => {
          "startTransition" in React__namespace ? React__namespace.startTransition(() => setStateImpl(newState)) : setStateImpl(newState);
        }, [setStateImpl]);
        React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
        return React__namespace.createElement(reactRouter.Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        });
      }
      {
        HistoryRouter.displayName = "unstable_HistoryRouter";
      }
      const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
      const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
      const Link = React__namespace.forwardRef(function LinkWithRef(_ref4, ref) {
        let {
          onClick,
          relative,
          reloadDocument,
          replace,
          state,
          target,
          to,
          preventScrollReset
        } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
        let {
          basename
        } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
        let absoluteHref;
        let isExternal = false;
        if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
          absoluteHref = to;
          if (isBrowser) {
            try {
              let currentUrl = new URL(window.location.href);
              let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
              let path = router.stripBasename(targetUrl.pathname, basename);
              if (targetUrl.origin === currentUrl.origin && path != null) {
                to = path + targetUrl.search + targetUrl.hash;
              } else {
                isExternal = true;
              }
            } catch (e) {
              router.UNSAFE_warning(false, '<Link to="' + to + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
            }
          }
        }
        let href = reactRouter.useHref(to, {
          relative
        });
        let internalOnClick = useLinkClickHandler(to, {
          replace,
          state,
          target,
          preventScrollReset,
          relative
        });
        function handleClick(event) {
          if (onClick)
            onClick(event);
          if (!event.defaultPrevented) {
            internalOnClick(event);
          }
        }
        return (
          // eslint-disable-next-line jsx-a11y/anchor-has-content
          React__namespace.createElement("a", _extends({}, rest, {
            href: absoluteHref || href,
            onClick: isExternal || reloadDocument ? onClick : handleClick,
            ref,
            target
          }))
        );
      });
      {
        Link.displayName = "Link";
      }
      const NavLink = React__namespace.forwardRef(function NavLinkWithRef(_ref5, ref) {
        let {
          "aria-current": ariaCurrentProp = "page",
          caseSensitive = false,
          className: classNameProp = "",
          end = false,
          style: styleProp,
          to,
          children
        } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
        let path = reactRouter.useResolvedPath(to, {
          relative: rest.relative
        });
        let location = reactRouter.useLocation();
        let routerState = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);
        let {
          navigator
        } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
        let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
        let locationPathname = location.pathname;
        let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
        if (!caseSensitive) {
          locationPathname = locationPathname.toLowerCase();
          nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
          toPathname = toPathname.toLowerCase();
        }
        let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
        let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
        let ariaCurrent = isActive ? ariaCurrentProp : void 0;
        let className;
        if (typeof classNameProp === "function") {
          className = classNameProp({
            isActive,
            isPending
          });
        } else {
          className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
        }
        let style = typeof styleProp === "function" ? styleProp({
          isActive,
          isPending
        }) : styleProp;
        return React__namespace.createElement(Link, _extends({}, rest, {
          "aria-current": ariaCurrent,
          className,
          ref,
          style,
          to
        }), typeof children === "function" ? children({
          isActive,
          isPending
        }) : children);
      });
      {
        NavLink.displayName = "NavLink";
      }
      const Form = React__namespace.forwardRef((props, ref) => {
        return React__namespace.createElement(FormImpl, _extends({}, props, {
          ref
        }));
      });
      {
        Form.displayName = "Form";
      }
      const FormImpl = React__namespace.forwardRef((_ref6, forwardedRef) => {
        let {
          reloadDocument,
          replace,
          method = defaultMethod,
          action,
          onSubmit,
          fetcherKey,
          routeId,
          relative,
          preventScrollReset
        } = _ref6, props = _objectWithoutPropertiesLoose(_ref6, _excluded3);
        let submit = useSubmitImpl(fetcherKey, routeId);
        let formMethod = method.toLowerCase() === "get" ? "get" : "post";
        let formAction = useFormAction(action, {
          relative
        });
        let submitHandler = (event) => {
          onSubmit && onSubmit(event);
          if (event.defaultPrevented)
            return;
          event.preventDefault();
          let submitter = event.nativeEvent.submitter;
          let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
          submit(submitter || event.currentTarget, {
            method: submitMethod,
            replace,
            relative,
            preventScrollReset
          });
        };
        return React__namespace.createElement("form", _extends({
          ref: forwardedRef,
          method: formMethod,
          action: formAction,
          onSubmit: reloadDocument ? onSubmit : submitHandler
        }, props));
      });
      {
        FormImpl.displayName = "FormImpl";
      }
      function ScrollRestoration(_ref7) {
        let {
          getKey,
          storageKey
        } = _ref7;
        useScrollRestoration({
          getKey,
          storageKey
        });
        return null;
      }
      {
        ScrollRestoration.displayName = "ScrollRestoration";
      }
      var DataRouterHook;
      (function(DataRouterHook2) {
        DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
        DataRouterHook2["UseSubmitImpl"] = "useSubmitImpl";
        DataRouterHook2["UseFetcher"] = "useFetcher";
      })(DataRouterHook || (DataRouterHook = {}));
      var DataRouterStateHook;
      (function(DataRouterStateHook2) {
        DataRouterStateHook2["UseFetchers"] = "useFetchers";
        DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
      })(DataRouterStateHook || (DataRouterStateHook = {}));
      function getDataRouterConsoleError(hookName) {
        return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
      }
      function useDataRouterContext(hookName) {
        let ctx = React__namespace.useContext(reactRouter.UNSAFE_DataRouterContext);
        !ctx ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : void 0;
        return ctx;
      }
      function useDataRouterState(hookName) {
        let state = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);
        !state ? router.UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : void 0;
        return state;
      }
      function useLinkClickHandler(to, _temp) {
        let {
          target,
          replace: replaceProp,
          state,
          preventScrollReset,
          relative
        } = _temp === void 0 ? {} : _temp;
        let navigate = reactRouter.useNavigate();
        let location = reactRouter.useLocation();
        let path = reactRouter.useResolvedPath(to, {
          relative
        });
        return React__namespace.useCallback((event) => {
          if (shouldProcessLinkClick(event, target)) {
            event.preventDefault();
            let replace = replaceProp !== void 0 ? replaceProp : reactRouter.createPath(location) === reactRouter.createPath(path);
            navigate(to, {
              replace,
              state,
              preventScrollReset,
              relative
            });
          }
        }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
      }
      function useSearchParams(defaultInit) {
        router.UNSAFE_warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.");
        let defaultSearchParamsRef = React__namespace.useRef(createSearchParams(defaultInit));
        let hasSetSearchParamsRef = React__namespace.useRef(false);
        let location = reactRouter.useLocation();
        let searchParams = React__namespace.useMemo(() => (
          // Only merge in the defaults if we haven't yet called setSearchParams.
          // Once we call that we want those to take precedence, otherwise you can't
          // remove a param with setSearchParams({}) if it has an initial value
          getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
        ), [location.search]);
        let navigate = reactRouter.useNavigate();
        let setSearchParams = React__namespace.useCallback((nextInit, navigateOptions) => {
          const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
          hasSetSearchParamsRef.current = true;
          navigate("?" + newSearchParams, navigateOptions);
        }, [navigate, searchParams]);
        return [searchParams, setSearchParams];
      }
      function useSubmit() {
        return useSubmitImpl();
      }
      function useSubmitImpl(fetcherKey, fetcherRouteId) {
        let {
          router: router$1
        } = useDataRouterContext(DataRouterHook.UseSubmitImpl);
        let {
          basename
        } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
        let currentRouteId = reactRouter.UNSAFE_useRouteId();
        return React__namespace.useCallback(function(target, options) {
          if (options === void 0) {
            options = {};
          }
          if (typeof document === "undefined") {
            throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
          }
          let {
            action,
            method,
            encType,
            formData
          } = getFormSubmissionInfo(target, options, basename);
          let opts = {
            preventScrollReset: options.preventScrollReset,
            formData,
            formMethod: method,
            formEncType: encType
          };
          if (fetcherKey) {
            !(fetcherRouteId != null) ? router.UNSAFE_invariant(false, "No routeId available for useFetcher()") : void 0;
            router$1.fetch(fetcherKey, fetcherRouteId, action, opts);
          } else {
            router$1.navigate(action, _extends({}, opts, {
              replace: options.replace,
              fromRouteId: currentRouteId
            }));
          }
        }, [router$1, basename, fetcherKey, fetcherRouteId, currentRouteId]);
      }
      function useFormAction(action, _temp2) {
        let {
          relative
        } = _temp2 === void 0 ? {} : _temp2;
        let {
          basename
        } = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
        let routeContext = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
        !routeContext ? router.UNSAFE_invariant(false, "useFormAction must be used inside a RouteContext") : void 0;
        let [match] = routeContext.matches.slice(-1);
        let path = _extends({}, reactRouter.useResolvedPath(action ? action : ".", {
          relative
        }));
        let location = reactRouter.useLocation();
        if (action == null) {
          path.search = location.search;
          path.hash = location.hash;
          if (match.route.index) {
            let params = new URLSearchParams(path.search);
            params.delete("index");
            path.search = params.toString() ? "?" + params.toString() : "";
          }
        }
        if ((!action || action === ".") && match.route.index) {
          path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
        }
        if (basename !== "/") {
          path.pathname = path.pathname === "/" ? basename : router.joinPaths([basename, path.pathname]);
        }
        return reactRouter.createPath(path);
      }
      function createFetcherForm(fetcherKey, routeId) {
        let FetcherForm = React__namespace.forwardRef((props, ref) => {
          return React__namespace.createElement(FormImpl, _extends({}, props, {
            ref,
            fetcherKey,
            routeId
          }));
        });
        {
          FetcherForm.displayName = "fetcher.Form";
        }
        return FetcherForm;
      }
      let fetcherId = 0;
      function useFetcher() {
        var _route$matches;
        let {
          router: router$1
        } = useDataRouterContext(DataRouterHook.UseFetcher);
        let route = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
        !route ? router.UNSAFE_invariant(false, "useFetcher must be used inside a RouteContext") : void 0;
        let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
        !(routeId != null) ? router.UNSAFE_invariant(false, 'useFetcher can only be used on routes that contain a unique "id"') : void 0;
        let [fetcherKey] = React__namespace.useState(() => String(++fetcherId));
        let [Form2] = React__namespace.useState(() => {
          !routeId ? router.UNSAFE_invariant(false, "No routeId available for fetcher.Form()") : void 0;
          return createFetcherForm(fetcherKey, routeId);
        });
        let [load] = React__namespace.useState(() => (href) => {
          !router$1 ? router.UNSAFE_invariant(false, "No router available for fetcher.load()") : void 0;
          !routeId ? router.UNSAFE_invariant(false, "No routeId available for fetcher.load()") : void 0;
          router$1.fetch(fetcherKey, routeId, href);
        });
        let submit = useSubmitImpl(fetcherKey, routeId);
        let fetcher = router$1.getFetcher(fetcherKey);
        let fetcherWithComponents = React__namespace.useMemo(() => _extends({
          Form: Form2,
          submit,
          load
        }, fetcher), [fetcher, Form2, submit, load]);
        React__namespace.useEffect(() => {
          return () => {
            if (!router$1) {
              console.warn("No router available to clean up from useFetcher()");
              return;
            }
            router$1.deleteFetcher(fetcherKey);
          };
        }, [router$1, fetcherKey]);
        return fetcherWithComponents;
      }
      function useFetchers() {
        let state = useDataRouterState(DataRouterStateHook.UseFetchers);
        return [...state.fetchers.values()];
      }
      const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
      let savedScrollPositions = {};
      function useScrollRestoration(_temp3) {
        let {
          getKey,
          storageKey
        } = _temp3 === void 0 ? {} : _temp3;
        let {
          router: router2
        } = useDataRouterContext(DataRouterHook.UseScrollRestoration);
        let {
          restoreScrollPosition,
          preventScrollReset
        } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);
        let location = reactRouter.useLocation();
        let matches = reactRouter.useMatches();
        let navigation = reactRouter.useNavigation();
        React__namespace.useEffect(() => {
          window.history.scrollRestoration = "manual";
          return () => {
            window.history.scrollRestoration = "auto";
          };
        }, []);
        usePageHide(React__namespace.useCallback(() => {
          if (navigation.state === "idle") {
            let key = (getKey ? getKey(location, matches) : null) || location.key;
            savedScrollPositions[key] = window.scrollY;
          }
          sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
          window.history.scrollRestoration = "auto";
        }, [storageKey, getKey, navigation.state, location, matches]));
        if (typeof document !== "undefined") {
          React__namespace.useLayoutEffect(() => {
            try {
              let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
              if (sessionPositions) {
                savedScrollPositions = JSON.parse(sessionPositions);
              }
            } catch (e) {
            }
          }, [storageKey]);
          React__namespace.useLayoutEffect(() => {
            let disableScrollRestoration = router2 == null ? void 0 : router2.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
            return () => disableScrollRestoration && disableScrollRestoration();
          }, [router2, getKey]);
          React__namespace.useLayoutEffect(() => {
            if (restoreScrollPosition === false) {
              return;
            }
            if (typeof restoreScrollPosition === "number") {
              window.scrollTo(0, restoreScrollPosition);
              return;
            }
            if (location.hash) {
              let el = document.getElementById(location.hash.slice(1));
              if (el) {
                el.scrollIntoView();
                return;
              }
            }
            if (preventScrollReset === true) {
              return;
            }
            window.scrollTo(0, 0);
          }, [location, restoreScrollPosition, preventScrollReset]);
        }
      }
      function useBeforeUnload(callback, options) {
        let {
          capture
        } = options || {};
        React__namespace.useEffect(() => {
          let opts = capture != null ? {
            capture
          } : void 0;
          window.addEventListener("beforeunload", callback, opts);
          return () => {
            window.removeEventListener("beforeunload", callback, opts);
          };
        }, [callback, capture]);
      }
      function usePageHide(callback, options) {
        let {
          capture
        } = options || {};
        React__namespace.useEffect(() => {
          let opts = capture != null ? {
            capture
          } : void 0;
          window.addEventListener("pagehide", callback, opts);
          return () => {
            window.removeEventListener("pagehide", callback, opts);
          };
        }, [callback, capture]);
      }
      function usePrompt(_ref8) {
        let {
          when,
          message
        } = _ref8;
        let blocker = reactRouter.unstable_useBlocker(when);
        React__namespace.useEffect(() => {
          if (blocker.state === "blocked" && !when) {
            blocker.reset();
          }
        }, [blocker, when]);
        React__namespace.useEffect(() => {
          if (blocker.state === "blocked") {
            let proceed = window.confirm(message);
            if (proceed) {
              setTimeout(blocker.proceed, 0);
            } else {
              blocker.reset();
            }
          }
        }, [blocker, message]);
      }
      Object.defineProperty(exports2, "AbortedDeferredError", {
        enumerable: true,
        get: function() {
          return reactRouter.AbortedDeferredError;
        }
      });
      Object.defineProperty(exports2, "Await", {
        enumerable: true,
        get: function() {
          return reactRouter.Await;
        }
      });
      Object.defineProperty(exports2, "MemoryRouter", {
        enumerable: true,
        get: function() {
          return reactRouter.MemoryRouter;
        }
      });
      Object.defineProperty(exports2, "Navigate", {
        enumerable: true,
        get: function() {
          return reactRouter.Navigate;
        }
      });
      Object.defineProperty(exports2, "NavigationType", {
        enumerable: true,
        get: function() {
          return reactRouter.NavigationType;
        }
      });
      Object.defineProperty(exports2, "Outlet", {
        enumerable: true,
        get: function() {
          return reactRouter.Outlet;
        }
      });
      Object.defineProperty(exports2, "Route", {
        enumerable: true,
        get: function() {
          return reactRouter.Route;
        }
      });
      Object.defineProperty(exports2, "Router", {
        enumerable: true,
        get: function() {
          return reactRouter.Router;
        }
      });
      Object.defineProperty(exports2, "RouterProvider", {
        enumerable: true,
        get: function() {
          return reactRouter.RouterProvider;
        }
      });
      Object.defineProperty(exports2, "Routes", {
        enumerable: true,
        get: function() {
          return reactRouter.Routes;
        }
      });
      Object.defineProperty(exports2, "UNSAFE_DataRouterContext", {
        enumerable: true,
        get: function() {
          return reactRouter.UNSAFE_DataRouterContext;
        }
      });
      Object.defineProperty(exports2, "UNSAFE_DataRouterStateContext", {
        enumerable: true,
        get: function() {
          return reactRouter.UNSAFE_DataRouterStateContext;
        }
      });
      Object.defineProperty(exports2, "UNSAFE_LocationContext", {
        enumerable: true,
        get: function() {
          return reactRouter.UNSAFE_LocationContext;
        }
      });
      Object.defineProperty(exports2, "UNSAFE_NavigationContext", {
        enumerable: true,
        get: function() {
          return reactRouter.UNSAFE_NavigationContext;
        }
      });
      Object.defineProperty(exports2, "UNSAFE_RouteContext", {
        enumerable: true,
        get: function() {
          return reactRouter.UNSAFE_RouteContext;
        }
      });
      Object.defineProperty(exports2, "UNSAFE_useRouteId", {
        enumerable: true,
        get: function() {
          return reactRouter.UNSAFE_useRouteId;
        }
      });
      Object.defineProperty(exports2, "createMemoryRouter", {
        enumerable: true,
        get: function() {
          return reactRouter.createMemoryRouter;
        }
      });
      Object.defineProperty(exports2, "createPath", {
        enumerable: true,
        get: function() {
          return reactRouter.createPath;
        }
      });
      Object.defineProperty(exports2, "createRoutesFromChildren", {
        enumerable: true,
        get: function() {
          return reactRouter.createRoutesFromChildren;
        }
      });
      Object.defineProperty(exports2, "createRoutesFromElements", {
        enumerable: true,
        get: function() {
          return reactRouter.createRoutesFromElements;
        }
      });
      Object.defineProperty(exports2, "defer", {
        enumerable: true,
        get: function() {
          return reactRouter.defer;
        }
      });
      Object.defineProperty(exports2, "generatePath", {
        enumerable: true,
        get: function() {
          return reactRouter.generatePath;
        }
      });
      Object.defineProperty(exports2, "isRouteErrorResponse", {
        enumerable: true,
        get: function() {
          return reactRouter.isRouteErrorResponse;
        }
      });
      Object.defineProperty(exports2, "json", {
        enumerable: true,
        get: function() {
          return reactRouter.json;
        }
      });
      Object.defineProperty(exports2, "matchPath", {
        enumerable: true,
        get: function() {
          return reactRouter.matchPath;
        }
      });
      Object.defineProperty(exports2, "matchRoutes", {
        enumerable: true,
        get: function() {
          return reactRouter.matchRoutes;
        }
      });
      Object.defineProperty(exports2, "parsePath", {
        enumerable: true,
        get: function() {
          return reactRouter.parsePath;
        }
      });
      Object.defineProperty(exports2, "redirect", {
        enumerable: true,
        get: function() {
          return reactRouter.redirect;
        }
      });
      Object.defineProperty(exports2, "renderMatches", {
        enumerable: true,
        get: function() {
          return reactRouter.renderMatches;
        }
      });
      Object.defineProperty(exports2, "resolvePath", {
        enumerable: true,
        get: function() {
          return reactRouter.resolvePath;
        }
      });
      Object.defineProperty(exports2, "unstable_useBlocker", {
        enumerable: true,
        get: function() {
          return reactRouter.unstable_useBlocker;
        }
      });
      Object.defineProperty(exports2, "useActionData", {
        enumerable: true,
        get: function() {
          return reactRouter.useActionData;
        }
      });
      Object.defineProperty(exports2, "useAsyncError", {
        enumerable: true,
        get: function() {
          return reactRouter.useAsyncError;
        }
      });
      Object.defineProperty(exports2, "useAsyncValue", {
        enumerable: true,
        get: function() {
          return reactRouter.useAsyncValue;
        }
      });
      Object.defineProperty(exports2, "useHref", {
        enumerable: true,
        get: function() {
          return reactRouter.useHref;
        }
      });
      Object.defineProperty(exports2, "useInRouterContext", {
        enumerable: true,
        get: function() {
          return reactRouter.useInRouterContext;
        }
      });
      Object.defineProperty(exports2, "useLoaderData", {
        enumerable: true,
        get: function() {
          return reactRouter.useLoaderData;
        }
      });
      Object.defineProperty(exports2, "useLocation", {
        enumerable: true,
        get: function() {
          return reactRouter.useLocation;
        }
      });
      Object.defineProperty(exports2, "useMatch", {
        enumerable: true,
        get: function() {
          return reactRouter.useMatch;
        }
      });
      Object.defineProperty(exports2, "useMatches", {
        enumerable: true,
        get: function() {
          return reactRouter.useMatches;
        }
      });
      Object.defineProperty(exports2, "useNavigate", {
        enumerable: true,
        get: function() {
          return reactRouter.useNavigate;
        }
      });
      Object.defineProperty(exports2, "useNavigation", {
        enumerable: true,
        get: function() {
          return reactRouter.useNavigation;
        }
      });
      Object.defineProperty(exports2, "useNavigationType", {
        enumerable: true,
        get: function() {
          return reactRouter.useNavigationType;
        }
      });
      Object.defineProperty(exports2, "useOutlet", {
        enumerable: true,
        get: function() {
          return reactRouter.useOutlet;
        }
      });
      Object.defineProperty(exports2, "useOutletContext", {
        enumerable: true,
        get: function() {
          return reactRouter.useOutletContext;
        }
      });
      Object.defineProperty(exports2, "useParams", {
        enumerable: true,
        get: function() {
          return reactRouter.useParams;
        }
      });
      Object.defineProperty(exports2, "useResolvedPath", {
        enumerable: true,
        get: function() {
          return reactRouter.useResolvedPath;
        }
      });
      Object.defineProperty(exports2, "useRevalidator", {
        enumerable: true,
        get: function() {
          return reactRouter.useRevalidator;
        }
      });
      Object.defineProperty(exports2, "useRouteError", {
        enumerable: true,
        get: function() {
          return reactRouter.useRouteError;
        }
      });
      Object.defineProperty(exports2, "useRouteLoaderData", {
        enumerable: true,
        get: function() {
          return reactRouter.useRouteLoaderData;
        }
      });
      Object.defineProperty(exports2, "useRoutes", {
        enumerable: true,
        get: function() {
          return reactRouter.useRoutes;
        }
      });
      exports2.BrowserRouter = BrowserRouter;
      exports2.Form = Form;
      exports2.HashRouter = HashRouter;
      exports2.Link = Link;
      exports2.NavLink = NavLink;
      exports2.ScrollRestoration = ScrollRestoration;
      exports2.UNSAFE_useScrollRestoration = useScrollRestoration;
      exports2.createBrowserRouter = createBrowserRouter;
      exports2.createHashRouter = createHashRouter;
      exports2.createSearchParams = createSearchParams;
      exports2.unstable_HistoryRouter = HistoryRouter;
      exports2.unstable_usePrompt = usePrompt;
      exports2.useBeforeUnload = useBeforeUnload;
      exports2.useFetcher = useFetcher;
      exports2.useFetchers = useFetchers;
      exports2.useFormAction = useFormAction;
      exports2.useLinkClickHandler = useLinkClickHandler;
      exports2.useSearchParams = useSearchParams;
      exports2.useSubmit = useSubmit;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});
export default require_react_router_dom_development();
/*! Bundled license information:

react-router-dom/dist/umd/react-router-dom.development.js:
  (**
   * React Router DOM v6.12.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=react-router-dom_dist_umd_react-router-dom__development.js.map
